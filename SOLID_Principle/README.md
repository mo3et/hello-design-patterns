# 设计模式六大原则 SOLID D

> [SOLID 面向对象设计 - wiki](https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))

SOLID 单一功能、开闭原则、里氏替换、接口隔离、依赖反转
## 单一职责原则 (Single Responsibility Principle) S
规定每个类都应该仅有一个单元的功能的原则。 万物基石?
- 一个类只负责完成一个职责或功能
- 高内聚，低耦合
- 并不是越细越好，要把握好尺度
> #### 需要拆分的场景 
> - 类中代码函数或属性过多
> - 私有方法过多
> - 类依赖的其他类过多
> - 类大量集中的方法都是集中操作类中的几个属性

## 开闭原则(Open Close Principle) O
- 对扩展开放，修改关闭
    - 新增方法、函数、属性、或者类
    - 减少直接修改方法函数类的内部代码
- 常见做法
    - 多态
    - 依赖注入
    - 基于接口而非实现
    - 装饰、策略、模版、职责链等大部分设计模式

## 里氏代换原则(Liskov Substitution Principle) L
- 子类对象能够替换程序中父类对象出现的的任何地方，并保证原来的逻辑行为不变及正确性不被破坏。
- 子类可以修改实现但不能修改约定
    - 函数的声明功能
    - 对输入输出的约定
    - 对异常的约定

## 接口隔离原则(Interface Segregation Principle) I
- 客户端不应该强迫依赖它不需要的接口
    - 客户端 调用方
    - 接口 可以是微服务的接口 or 某个类库的接口
- 如果只依赖函数或者说API接口的部分功能，就应该进行拆分

## 依赖反转原则(Dependence Inversion Principle) D
- 控制反转
    - "控制"是指对程序流程的控制
    - "反转"是指在没用框架之前，程序员自己控制整个程序的执行
    - 使用框架后，将程序的执行流程通过框架来控制。流程的控制权反转了
- 依赖注入
    - 不通过 new 的方式在类内部创建依赖类的对象
    - 而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(或"注入")给类来使用。
- 依赖注入框架
    - dig 基于反射
    - wire 基于 Generate
- 依赖倒置原则
    - 高层模块不依赖底层模块，他们共同依赖同一个抽象。抽象不需要依赖具体事项细节，具体实现细节依赖抽象。

## 迪米特法则 (最少知道原则)(Demeter Principle)
- 不该有直接依赖关系的类之间，不要有依赖
- 有依赖关系的类之间，保持最小依赖
